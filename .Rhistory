#return(summary(model))
corr_coef <- cor(N_obs, predict(model))
#return(corr_coef)
#lines(times,predict(model),col="red",lty=2,lwd=2)
#n = length(times)
## add model predictions
#a = summary(model)$coefficient[1]
#b = summary(model)$coefficient[2]
#lines(times,predict(model),col="red",lty=2,lwd=2)
## add variances - first, find standard errors
#a_se = summary(model)$coefficients[3]
#b_se = summary(model)$coefficients[4]
## compute standard deviations
#a_sd = a_se * sqrt(n)
#b_sd = b_se * sqrt(n)
# compute upper bounds of model prediction
#UP = (a + a_sd) * times / (b - b_sd + times)
#lines(times, UP, col = 'red', lty = "dashed")
#LW = (a - a_sd) * times / (b + b_sd + times)
#lines(times, LW, col ='red', lty = 'dashed')
#return(summary(model))
return('correlation coefficient' = corr_coef)
}
}
taxamodel_cor_test("Animalia", "Phylum", "logistic")
taxamodel_cor_test("Animalia", "Phylum", "logistic")
taxamodel_cor_test <- function(taxa, rank, method) {
df <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa |
Orders == taxa | Families == taxa | Genera == taxa)
dt = as.data.table(unique(df))
setkey(dt, "year")
if(rank == "Phylum") {
dt[, id := as.numeric(factor(Phyla, levels = unique(Phyla)))]
ranklabel = "phyla"
} else if(rank == "Class") {
dt[, id := as.numeric(factor(Classes, levels = unique(Classes)))]
ranklabel = "classes"
} else if(rank == "Order") {
dt[, id := as.numeric(factor(Orders, levels = unique(Orders)))]
ranklabel = "orders"
} else if(rank == "Family") {
dt[, id := as.numeric(factor(Families, levels = unique(Families)))]
ranklabel = "families"
} else if(rank == "Genus") {
dt[, id := as.numeric(factor(Genera, levels = unique(Genera)))]
ranklabel = "genera"
} else if(rank == "Species") {
dt[, id := as.numeric(factor(AphiaIDs, levels = unique(AphiaIDs)))]
ranklabel = "species"
}
setkey(dt, "year", "id")
dt.out <- dt[J(unique(year)), mult = "last"]#[, Phylum := NULL]
dt.out[, id := cummax(id)]
numtaxa <- cummax(as.numeric(factor(dt$id)))
taxa_dt <- aggregate(numtaxa, list(year = dt$year), max )
colnames(taxa_dt) <- c("year", "taxa count")
#plot(taxa_dt$year, taxa_dt$`taxa count`, xlab = "Year", ylab = paste("Number of", ranklabel, sep = " "), ylim = c(0, max(taxa_dt$"taxa count")*1.35))
#title(taxa)
if(method == "logistic") {
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
SS<-getInitial(N_obs~SSlogis(times,alpha,xmid,scale),data=data.frame(N_obs=N_obs,times=times))
K_start <- SS["alpha"]
R_start <- 1/SS["scale"]
N0_start <- SS["alpha"]/(exp(SS["xmid"]/SS["scale"])) + 1
#return(summary(SS))
log_formula<-formula(N_obs ~ K * N0 * exp(R * times) / (K + N0 * (exp(R * times) - 1)))
m<-nls(log_formula,start = list(K = K_start, R = R_start, N0 = N0_start))
#estimated parameters
#summary(m)
corr_coef <- cor(N_obs,predict(m))
#return(corr_coef)
#lines(times,predict(m),col="red",lty=2,lwd=2)
#n = length(times)
## add model predictions
#K = summary(m)$coefficient[1]
#R = summary(m)$coefficient[2]
#N0 = summary(m)$coefficient[3]
## add variances - first, find standard errors
#K_se = summary(m)$coefficients[4]
#R_se = summary(m)$coefficients[5]
#N0_se = summary(m)$coefficients[6]
## compute standard deviations
#K_sd = K_se * sqrt(n)
#R_sd = R_se * sqrt(n)
#N0_sd = N0_se * sqrt(n)
# compute upper bounds of model prediction
#UP = (K + K_sd) * (N0 + N0_sd) * exp((R + R_sd)*times)/((K + K_sd)+(N0 + N0_sd)*(exp((R + R_sd)*times)-1))
#lines(times, UP, col = 'red', lty = "dashed")
#LW = (K - K_sd) * (N0 - N0_sd) * exp((R - R_sd)*times)/((K - K_sd)+(N0 - N0_sd)*(exp((R - R_sd)*times)-1))
#lines(times, LW, col ='red', lty = 'dashed')
return('correlation coefficient' = corr_coef)
} else if(method == "Michaelis-Menten") {
# refer to this page https://stackoverflow.com/questions/27547548/solving-error-message-step-halving-factor-reduced-below-minimum-in-nls-step-a
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
MM <- getInitial(N_obs~SSmicmen(times, Vm, K),data=data.frame(N_obs=N_obs,times=times))
Vm_start <- MM["Vm"]
K_start <- MM["K"]
#model <- nls(N_obs ~ SSmicmen(N_obs, Vm, K), data = dd)
model <- nls(N_obs ~ Vm * times / (K + times), start = list(Vm = Vm_start, K = K_start))
#return(summary(model))
corr_coef <- cor(N_obs, predict(model))
#return(corr_coef)
#lines(times,predict(model),col="red",lty=2,lwd=2)
#n = length(times)
## add model predictions
#a = summary(model)$coefficient[1]
#b = summary(model)$coefficient[2]
#lines(times,predict(model),col="red",lty=2,lwd=2)
## add variances - first, find standard errors
#a_se = summary(model)$coefficients[3]
#b_se = summary(model)$coefficients[4]
## compute standard deviations
#a_sd = a_se * sqrt(n)
#b_sd = b_se * sqrt(n)
# compute upper bounds of model prediction
#UP = (a + a_sd) * times / (b - b_sd + times)
#lines(times, UP, col = 'red', lty = "dashed")
#LW = (a - a_sd) * times / (b + b_sd + times)
#lines(times, LW, col ='red', lty = 'dashed')
#return(summary(model))
return('correlation coefficient' = corr_coef)
}
}
taxamodel_cor_test("Animalia", "Phylum", "logistic")
taxamodel_cor_test("Animalia", "Phylum", "Michaelis-Menten")
taxamodel_cor_test <- function(taxa, rank, method) {
df <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa |
Orders == taxa | Families == taxa | Genera == taxa)
dt = as.data.table(unique(df))
setkey(dt, "year")
if(rank == "Phylum") {
dt[, id := as.numeric(factor(Phyla, levels = unique(Phyla)))]
ranklabel = "phyla"
} else if(rank == "Class") {
dt[, id := as.numeric(factor(Classes, levels = unique(Classes)))]
ranklabel = "classes"
} else if(rank == "Order") {
dt[, id := as.numeric(factor(Orders, levels = unique(Orders)))]
ranklabel = "orders"
} else if(rank == "Family") {
dt[, id := as.numeric(factor(Families, levels = unique(Families)))]
ranklabel = "families"
} else if(rank == "Genus") {
dt[, id := as.numeric(factor(Genera, levels = unique(Genera)))]
ranklabel = "genera"
} else if(rank == "Species") {
dt[, id := as.numeric(factor(AphiaIDs, levels = unique(AphiaIDs)))]
ranklabel = "species"
}
setkey(dt, "year", "id")
dt.out <- dt[J(unique(year)), mult = "last"]#[, Phylum := NULL]
dt.out[, id := cummax(id)]
numtaxa <- cummax(as.numeric(factor(dt$id)))
taxa_dt <- aggregate(numtaxa, list(year = dt$year), max )
colnames(taxa_dt) <- c("year", "taxa count")
if(method == "logistic") {
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
SS<-getInitial(N_obs~SSlogis(times,alpha,xmid,scale),data=data.frame(N_obs=N_obs,times=times))
K_start <- SS["alpha"]
R_start <- 1/SS["scale"]
N0_start <- SS["alpha"]/(exp(SS["xmid"]/SS["scale"])) + 1
log_formula<-formula(N_obs ~ K * N0 * exp(R * times) / (K + N0 * (exp(R * times) - 1)))
m<-nls(log_formula,start = list(K = K_start, R = R_start, N0 = N0_start))
corr_coef <- cor(N_obs,predict(m))
return('correlation coefficient' = corr_coef)
} else if(method == "Michaelis-Menten") {
# refer to this page https://stackoverflow.com/questions/27547548/solving-error-message-step-halving-factor-reduced-below-minimum-in-nls-step-a
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
MM <- getInitial(N_obs~SSmicmen(times, Vm, K),data=data.frame(N_obs=N_obs,times=times))
Vm_start <- MM["Vm"]
K_start <- MM["K"]
#model <- nls(N_obs ~ SSmicmen(N_obs, Vm, K), data = dd)
model <- nls(N_obs ~ Vm * times / (K + times), start = list(Vm = Vm_start, K = K_start))
corr_coef <- cor(N_obs, predict(model))
return('correlation coefficient' = corr_coef)
}
}
taxamodel_cor_test("Animalia", "Phylum", "Michaelis-Menten")
taxamodel_cor_test("Animalia", "Phylum", "logistic")
devtools::document
getwd()
devtools::document()
devtools::library()
devtools::library()
devtools::check()
devtools::install()
library(biotaxa)
taxamodel_cor_test("Animalia", "Phylum", "logistic")
taxamodel_cor_test("Animalia", "Phylum", "Michaelis-Menten")
taxamodel("Animalia", "Phylum", "logistic")
taxamodel_cor_test <- function(taxa, rank, method) {
df <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa |
Orders == taxa | Families == taxa | Genera == taxa)
dt = as.data.table(unique(df))
setkey(dt, "year")
if(rank == "Phylum") {
dt[, id := as.numeric(factor(Phyla, levels = unique(Phyla)))]
ranklabel = "phyla"
} else if(rank == "Class") {
dt[, id := as.numeric(factor(Classes, levels = unique(Classes)))]
ranklabel = "classes"
} else if(rank == "Order") {
dt[, id := as.numeric(factor(Orders, levels = unique(Orders)))]
ranklabel = "orders"
} else if(rank == "Family") {
dt[, id := as.numeric(factor(Families, levels = unique(Families)))]
ranklabel = "families"
} else if(rank == "Genus") {
dt[, id := as.numeric(factor(Genera, levels = unique(Genera)))]
ranklabel = "genera"
} else if(rank == "Species") {
dt[, id := as.numeric(factor(AphiaIDs, levels = unique(AphiaIDs)))]
ranklabel = "species"
}
setkey(dt, "year", "id")
dt.out <- dt[J(unique(year)), mult = "last"]#[, Phylum := NULL]
dt.out[, id := cummax(id)]
numtaxa <- cummax(as.numeric(factor(dt$id)))
taxa_dt <- aggregate(numtaxa, list(year = dt$year), max )
colnames(taxa_dt) <- c("year", "taxa count")
if(method == "logistic") {
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
SS<-getInitial(N_obs~SSlogis(times,alpha,xmid,scale),data=data.frame(N_obs=N_obs,times=times))
K_start <- SS["alpha"]
R_start <- 1/SS["scale"]
N0_start <- SS["alpha"]/(exp(SS["xmid"]/SS["scale"])) + 1
log_formula<-formula(N_obs ~ K * N0 * exp(R * times) / (K + N0 * (exp(R * times) - 1)))
m<-nls(log_formula,start = list(K = K_start, R = R_start, N0 = N0_start))
corr_coef <- cor(N_obs,predict(m))
return('correlation coefficient' = corr_coef)
} else if(method == "Michaelis-Menten") {
# refer to this page https://stackoverflow.com/questions/27547548/solving-error-message-step-halving-factor-reduced-below-minimum-in-nls-step-a
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
MM <- getInitial(N_obs~SSmicmen(times, Vm, K),data=data.frame(N_obs=N_obs,times=times))
Vm_start <- MM["Vm"]
K_start <- MM["K"]
#model <- nls(N_obs ~ SSmicmen(N_obs, Vm, K), data = dd)
model <- nls(N_obs ~ Vm * times / (K + times), start = list(Vm = Vm_start, K = K_start))
corr_coef <- cor(N_obs, predict(model))
return('correlation coefficient' = corr_coef)
}
}
taxa_model_cor_test("Animalia", "Phylum", "logistic")
taxamodel_cor_test("Animalia", "Phylum", "logistic")
rm(list = ls())
devtools::document()
devtools::document()
devtools::install()
devtools::check()
library(biotaxa)
taxaaccm("Animalia", "Phylum")
taxaaccum("Animalia", "Phylum")
taxamodel("Animalia", "Phylum", "logistic")
taxamodel_cor("Animalia", "Phylum", "logistic")
frequencyrank("Animalia", "Phylum")
topn("Animalia", "Phylum", 2)
library(dplyr::count)
library(dplyr::count())
knitr::opts_chunk$set(echo = TRUE)
frequencyrank <- function(taxa, rank) {
library(dplyr)
df <- as.data.frame(subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa | Orders == taxa | Families == taxa | Genera == taxa))
if(rank == "Phylum") {
df_mid <- count(df, df$Phyla)
} else if(rank == "Class") {
df_mid <- count(df, df$Classes)
} else if(rank == "Order") {
df_mid <- count(df, df$Order)
} else if(rank == "Family") {
df_mid <- count(df, df$Families)
} else if(rank == "Genus") {
df_mid <- count(df, df$Genera)
}
df_mid <- as.data.frame(df_mid)
colnames(df_mid) <- c(taxa, "freq")
df_end <- df_mid[with(df_mid, order(-freq)),]
colnames(df_end) <- c(rank, "freq")
return(df_end)
}
knitr::opts_chunk$set(echo = TRUE)
#load the dataset of interest
#check the dimension of the dataset
library(biotaxa)
dim(data_m)
#The column names of the dataset should include year and all required taxonomic hierarchical levels. Nevertheless, the do not need to be in the same order as that of the example dataset.
colnames(data_m)
library(data.table)
taxaaccum <- function(taxa, rank) {
df <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa | Orders == taxa | Families == taxa | Genera == taxa)
dt = as.data.table(unique(df))
setkey(dt, "year")
if (rank == "Phylum") {
dt[, id := as.numeric(factor(Phyla, levels = unique(Phyla)))]
ranklabel = "phyla"
} else if (rank == "Class") {
dt[, id := as.numeric(factor(Classes, levels = unique(Classes)))]
ranklabel = "classes"
} else if (rank == "Order") {
dt[, id := as.numeric(factor(Orders, levels = unique(Orders)))]
ranklabel = "orders"
} else if (rank == "Family") {
dt[, id := as.numeric(factor(Families, levels = unique(Families)))]
ranklabel = "families"
} else if (rank == "Genus") {
dt[, id := as.numeric(factor(Genera, levels = unique(Genera)))]
ranklabel = "genera"
} else if (rank == "Species") {
dt[, id := as.numeric(factor(AphiaIDs, levels = unique(AphiaIDs)))]
ranklabel = "species"
}
setkey(dt, "year", "id")
dt.out <- dt[J(unique(year)), mult = "last"]#[, Phylum := NULL]
dt.out[, id := cummax(id)]
numtaxa <- cummax(as.numeric(factor(dt$id)))
taxa_dt <- aggregate(numtaxa, list(year = dt$year), max )
colnames(taxa_dt) <- c("year", "taxa count")
plot(taxa_dt$year, taxa_dt$`taxa count`, xlab = "Year", ylab = paste("Number of", ranklabel, sep = " "))
title(taxa)
}
#Example
taxaaccum(taxa = "Animalia", rank = "Phylum")
library(data.table)
taxamodel <- function(taxa, rank, method) {
tryCatch({
df <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa |
Orders == taxa | Families == taxa | Genera == taxa)
dt = as.data.table(unique(df))
setkey(dt, "year")
if(rank == "Phylum") {
dt[, id := as.numeric(factor(Phyla, levels = unique(Phyla)))]
ranklabel = "phyla"
} else if(rank == "Class") {
dt[, id := as.numeric(factor(Classes, levels = unique(Classes)))]
ranklabel = "classes"
} else if(rank == "Order") {
dt[, id := as.numeric(factor(Orders, levels = unique(Orders)))]
ranklabel = "orders"
} else if(rank == "Family") {
dt[, id := as.numeric(factor(Families, levels = unique(Families)))]
ranklabel = "families"
} else if(rank == "Genus") {
dt[, id := as.numeric(factor(Genera, levels = unique(Genera)))]
ranklabel = "genera"
} else if(rank == "Species") {
dt[, id := as.numeric(factor(AphiaIDs, levels = unique(AphiaIDs)))]
ranklabel = "species"
}
setkey(dt, "year", "id")
dt.out <- dt[J(unique(year)), mult = "last"]#[, Phylum := NULL]
dt.out[, id := cummax(id)]
numtaxa <- cummax(as.numeric(factor(dt$id)))
taxa_dt <- aggregate(numtaxa, list(year = dt$year), max )
colnames(taxa_dt) <- c("year", "taxa count")
plot(taxa_dt$year, taxa_dt$`taxa count`, xlab = "Year", ylab = paste("Number of", ranklabel, sep = " "), ylim = c(0, max(taxa_dt$"taxa count")*1.35))
title(taxa)
if(method == "logistic") {
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
SS<-getInitial(N_obs~SSlogis(times,alpha,xmid,scale),data=data.frame(N_obs=N_obs,times=times))
K_start <- SS["alpha"]
R_start <- 1/SS["scale"]
N0_start <- SS["alpha"]/(exp(SS["xmid"]/SS["scale"])) + 1
log_formula<-formula(N_obs ~ K * N0 * exp(R * times) / (K + N0 * (exp(R * times) - 1)))
m<-nls(log_formula,start = list(K = K_start, R = R_start, N0 = N0_start))
corr_coef <- cor(N_obs,predict(m))
lines(times,predict(m),col="red",lty=2,lwd=2)
n = length(times)
K = summary(m)$coefficient[1]
R = summary(m)$coefficient[2]
N0 = summary(m)$coefficient[3]
## add variances - first, find standard errors
K_se = summary(m)$coefficients[4]
R_se = summary(m)$coefficients[5]
N0_se = summary(m)$coefficients[6]
## compute standard deviations
K_sd = K_se * sqrt(n)
R_sd = R_se * sqrt(n)
N0_sd = N0_se * sqrt(n)
# compute upper bounds of model prediction
UP = (K + K_sd) * (N0 + N0_sd) * exp((R + R_sd)*times)/((K + K_sd)+(N0 + N0_sd)*(exp((R + R_sd)*times)-1))
lines(times, UP, col = 'red', lty = "dashed")
LW = (K - K_sd) * (N0 - N0_sd) * exp((R - R_sd)*times)/((K - K_sd)+(N0 - N0_sd)*(exp((R - R_sd)*times)-1))
lines(times, LW, col ='red', lty = 'dashed')
return('correlation coefficient' = corr_coef)
} else if(method == "Michaelis-Menten") {
# refer to this page https://stackoverflow.com/questions/27547548/solving-error-message-step-halving-factor-reduced-below-minimum-in-nls-step-a
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
MM <- getInitial(N_obs~SSmicmen(times, Vm, K),data=data.frame(N_obs=N_obs,times=times))
Vm_start <- MM["Vm"]
K_start <- MM["K"]
model <- nls(N_obs ~ Vm * times / (K + times), start = list(Vm = Vm_start, K = K_start))
corr_coef <- cor(N_obs, predict(model))
#return(corr_coef)
lines(times,predict(model),col="red",lty=2,lwd=2)
n = length(times)
## add model predictions
a = summary(model)$coefficient[1]
b = summary(model)$coefficient[2]
lines(times,predict(model),col="red",lty=2,lwd=2)
## add variances - first, find standard errors
a_se = summary(model)$coefficients[3]
b_se = summary(model)$coefficients[4]
## compute standard deviations
a_sd = a_se * sqrt(n)
b_sd = b_se * sqrt(n)
# compute upper bounds of model prediction
UP = (a + a_sd) * times / (b - b_sd + times)
lines(times, UP, col = 'red', lty = "dashed")
LW = (a - a_sd) * times / (b + b_sd + times)
lines(times, LW, col ='red', lty = 'dashed')
return('correlation coefficient' = corr_coef)
}
}, error = function(e) {list(taxa = taxa, rank = rank, method = method, corr_coef = cat("model fails to converge", "\n"))})
}
#example
taxamodel("Animalia", "Phylum", "logistic")
taxamodel_cor <- function(taxa, rank, method) {
tryCatch({
df <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa | Orders == taxa | Families == taxa | Genera == taxa)
dt = as.data.table(unique(df))
setkey(dt, "year")
if(rank == "Phylum") {
dt[, id := as.numeric(factor(Phyla, levels = unique(Phyla)))]
ranklabel = "phyla"
} else if(rank == "Class") {
dt[, id := as.numeric(factor(Classes, levels = unique(Classes)))]
ranklabel = "classes"
} else if(rank == "Order") {
dt[, id := as.numeric(factor(Orders, levels = unique(Orders)))]
ranklabel = "orders"
} else if(rank == "Family") {
dt[, id := as.numeric(factor(Families, levels = unique(Families)))]
ranklabel = "families"
} else if(rank == "Genus") {
dt[, id := as.numeric(factor(Genera, levels = unique(Genera)))]
ranklabel = "genera"
} else if(rank == "Species") {
dt[, id := as.numeric(factor(AphiaIDs, levels = unique(AphiaIDs)))]
ranklabel = "species"
}
setkey(dt, "year", "id")
dt.out <- dt[J(unique(year)), mult = "last"]#[, Phylum := NULL]
dt.out[, id := cummax(id)]
numtaxa <- cummax(as.numeric(factor(dt$id)))
taxa_dt <- aggregate(numtaxa, list(year = dt$year), max )
colnames(taxa_dt) <- c("year", "taxa count")
N_obs <- taxa_dt$'taxa count'
times <- as.numeric(taxa_dt$year)
if(method == "logistic") {
SS<-getInitial(N_obs~SSlogis(times,alpha,xmid,scale),data=data.frame(N_obs=N_obs,times=times))
K_start <- SS["alpha"]
R_start <- 1/SS["scale"]
N0_start <- SS["alpha"]/(exp(SS["xmid"]/SS["scale"])) + 1
log_formula<-formula(N_obs ~ K * N0 * exp(R * times) / (K + N0 * (exp(R * times) - 1)))
m<-nls(log_formula,start = list(K = K_start, R = R_start, N0 = N0_start))
corr_coef <- cor(N_obs,predict(m))
res <- list(taxa=taxa, rank=rank, method=method, corr_coef=corr_coef)
return(res)
} else if(method == "Michaelis-Menten") {
MM <- getInitial(N_obs~SSmicmen(times, Vm, K),data=data.frame(N_obs=N_obs,times=times))
Vm_start <- MM["Vm"]
K_start <- MM["K"]
model <- nls(N_obs ~ Vm * times / (K + times), start = list(Vm = Vm_start, K = K_start))
corr_coef <- cor(N_obs, predict(model))
res <- list(taxa=taxa, rank=rank, method=method, corr_coef=corr_coef)
return(res)
}
}, error = function(e) {list(taxa = taxa, rank = rank, method = method, corr_coef = cat("model fails to converge", "\n"))})
}
#example
taxamodel_cor(taxa = "Animalia", rank = "Class", method = "logistic")
taxaprecision <- function(taxa) {
taxa <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa | Orders == taxa | Families == taxa | Genera == taxa)
species_complete <- which(taxa$AphiaIDs != "")
all_species <- dim(taxa)[[1]][1]
species_precision = length(species_complete) / all_species
return(species_precision)
}
#example
taxaprecision("Isodictya")
?invisible
taxaaccum("Animalia", "Phylum")
taxamodel("Animalia", "Phylum", "logictic")
taxamodel("Animalia", "Phylum", "logistic")
taxamodel("Animalia", "Phylum", "Michaelis-Menten")
taxamodel_cpr("Animalia", "Phylum", "Michaelis-Menten")
taxamodel_cor("Animalia", "Phylum", "Michaelis-Menten")
frequencyrank("Animalia", "Phylum")
topn("Animalia", "Phylum", 5)
head(data_m)
library(biotaxa)
taxamodel("Animalia", "Phylum", "logistic")
taxamodel("Animalia", "Phylum", "Michaelis-Menten")
taxamodel("Animalia", "Class", "Michaelis-Menten")
taxamodel("Animalia", "Class", "logistic")
devtools::document()
devtools::install()
library(biotaxa)
head(data_m)
taxaaccum("Animalia", "Phylum")
taxamode("Animalia", "Phylum", "logistic")
taxamodel("Animalia", "Phylum", "logistic")
taxamodel("Animalia", "Phylum", "Michaelis-Menten")
which(data_m == "Epimeria")
length(which(data_m == "Epimeria"))
