{
    "collab_server" : "",
    "contents" : "#'Fitting the taxonomic accumulation of a given taxa with user-selected logistic or Michaelis-Menten model\n#'\n#' @param taxa A string.\n#' @param rank A string.\n#' @param method A string.\n#' @return an accumulative curve of taxa overlapped with a fitting curve of selected model\n#' @examples taxamodel(\"Animalia\", \"Phyla\", \"logistic\")\n\ntaxamodel <- function(taxa, rank, method) {\n  df <- subset(data_m, Kingdoms == taxa | Phyla == taxa | Classes == taxa |\n      Orders == taxa | Families == taxa | Genera == taxa)\n  dt = as.data.table(unique(df))\n  setkey(dt, \"year\")\n  if(rank == \"Phylum\") {\n    dt[, id := as.numeric(factor(Phyla, levels = unique(Phyla)))]\n    ranklabel = \"phyla\"\n  } else if(rank == \"Class\") {\n    dt[, id := as.numeric(factor(Classes, levels = unique(Classes)))]\n    ranklabel = \"classes\"\n  } else if(rank == \"Order\") {\n    dt[, id := as.numeric(factor(Orders, levels = unique(Orders)))]\n    ranklabel = \"orders\"\n  } else if(rank == \"Family\") {\n    dt[, id := as.numeric(factor(Families, levels = unique(Families)))]\n    ranklabel = \"families\"\n  } else if(rank == \"Genus\") {\n    dt[, id := as.numeric(factor(Genera, levels = unique(Genera)))]\n    ranklabel = \"genera\"\n  } else if(rank == \"Species\") {\n    dt[, id := as.numeric(factor(AphiaIDs, levels = unique(AphiaIDs)))]\n    ranklabel = \"species\"\n  }\n  setkey(dt, \"year\", \"id\")\n  dt.out <- dt[J(unique(year)), mult = \"last\"]#[, Phylum := NULL]\n  dt.out[, id := cummax(id)]\n  numtaxa <- cummax(as.numeric(factor(dt$id)))\n  taxa_dt <- aggregate(numtaxa, list(year = dt$year), max )\n  colnames(taxa_dt) <- c(\"year\", \"taxa count\")\n  plot(taxa_dt$year, taxa_dt$`taxa count`, xlab = \"Year\", ylab = paste(\"Number of\", ranklabel, sep = \" \"), ylim = c(0, max(taxa_dt$\"taxa count\")*1.35))\n  title(taxa)\n\n  if(method == \"logistic\") {\n    N_obs <- taxa_dt$'taxa count'\n    times <- as.numeric(taxa_dt$year)\n\n    SS<-getInitial(N_obs~SSlogis(times,alpha,xmid,scale),data=data.frame(N_obs=N_obs,times=times))\n    K_start <- SS[\"alpha\"]\n    R_start <- 1/SS[\"scale\"]\n    N0_start <- SS[\"alpha\"]/(exp(SS[\"xmid\"]/SS[\"scale\"])) + 1\n    #return(summary(SS))\n\n    log_formula<-formula(N_obs ~ K * N0 * exp(R * times) / (K + N0 * (exp(R * times) - 1)))\n    m<-nls(log_formula,start = list(K = K_start, R = R_start, N0 = N0_start))\n    #estimated parameters\n    #summary(m)\n\n    corr_coef <- cor(N_obs,predict(m))\n    #return(corr_coef)\n    lines(times,predict(m),col=\"red\",lty=2,lwd=2)\n    n = length(times)\n\n    ## add model predictions\n    K = summary(m)$coefficient[1]\n    R = summary(m)$coefficient[2]\n    N0 = summary(m)$coefficient[3]\n\n    ## add variances - first, find standard errors\n    K_se = summary(m)$coefficients[4]\n    R_se = summary(m)$coefficients[5]\n    N0_se = summary(m)$coefficients[6]\n\n    ## compute standard deviations\n    K_sd = K_se * sqrt(n)\n    R_sd = R_se * sqrt(n)\n    N0_sd = N0_se * sqrt(n)\n\n    # compute upper bounds of model prediction\n    UP = (K + K_sd) * (N0 + N0_sd) * exp((R + R_sd)*times)/((K + K_sd)+(N0 + N0_sd)*(exp((R + R_sd)*times)-1))\n    lines(times, UP, col = 'red', lty = \"dashed\")\n    LW = (K - K_sd) * (N0 - N0_sd) * exp((R - R_sd)*times)/((K - K_sd)+(N0 - N0_sd)*(exp((R - R_sd)*times)-1))\n    lines(times, LW, col ='red', lty = 'dashed')\n    return('correlation coefficient' = corr_coef)\n  } else if(method == \"Michaelis-Menten\") {\n\n    # refer to this page https://stackoverflow.com/questions/27547548/solving-error-message-step-halving-factor-reduced-below-minimum-in-nls-step-a\n\n    N_obs <- taxa_dt$'taxa count'\n    times <- as.numeric(taxa_dt$year)\n\n    MM <- getInitial(N_obs~SSmicmen(times, Vm, K),data=data.frame(N_obs=N_obs,times=times))\n\n    Vm_start <- MM[\"Vm\"]\n    K_start <- MM[\"K\"]\n\n    #model <- nls(N_obs ~ SSmicmen(N_obs, Vm, K), data = dd)\n    model <- nls(N_obs ~ Vm * times / (K + times), start = list(Vm = Vm_start, K = K_start))\n    #return(summary(model))\n\n    corr_coef <- cor(N_obs, predict(model))\n    #return(corr_coef)\n    lines(times,predict(model),col=\"red\",lty=2,lwd=2)\n    n = length(times)\n    ## add model predictions\n    a = summary(model)$coefficient[1]\n    b = summary(model)$coefficient[2]\n    lines(times,predict(model),col=\"red\",lty=2,lwd=2)\n    ## add variances - first, find standard errors\n    a_se = summary(model)$coefficients[3]\n    b_se = summary(model)$coefficients[4]\n    ## compute standard deviations\n    a_sd = a_se * sqrt(n)\n    b_sd = b_se * sqrt(n)\n    # compute upper bounds of model prediction\n    UP = (a + a_sd) * times / (b - b_sd + times)\n    lines(times, UP, col = 'red', lty = \"dashed\")\n    LW = (a - a_sd) * times / (b + b_sd + times)\n    lines(times, LW, col ='red', lty = 'dashed')\n    #return(summary(model))\n    return('correlation coefficient' = corr_coef)\n  }\n}\n",
    "created" : 1505122069431.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1343293104",
    "id" : "46A6A1E1",
    "lastKnownWriteTime" : 1505135062,
    "last_content_update" : 1505135062059,
    "path" : "~/Documents/R packages/biotaxa/R/taxamodel.R",
    "project_path" : "R/taxamodel.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 12,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}